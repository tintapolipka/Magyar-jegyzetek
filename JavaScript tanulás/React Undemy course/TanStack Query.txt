A TanStack Query egy React-t√≥l f√ºggetlen gy√°rt√≥t√≥l sz√°rmaz√≥ kieg√©sz√≠t≈ë csomag.
Els≈ë sorban a FETCH-el√©s √©s SERVER STATE kezel√©s megk√∂nny√≠t√©s√©re lehet haszn√°lni Reactban, √©s m√°s async funkci√≥khoz, (de m√°s funkci√≥kkal nem foglalkozunk itt.)

# TELEP√çT√âSE:
Node.js kell hozz√°.
Ekkor a termin√°lba:
npm i @tanstack/react-query

# R√∂vid p√©lda a haszn√°latra:
```javascript
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const { isPending, error, data } = useQuery({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/TanStack/query').then((res) =>
        res.json(),
      ),
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
    </div>
  )
}
```
Ez a k√≥d egy egyszer≈± React alkalmaz√°s, amely a @tanstack/react-query k√∂nyvt√°rat haszn√°lja az adatok aszinkron lek√©rdez√©s√©re √©s kezel√©s√©re. L√°ssuk r√©szletesen:

## K√∂nyvt√°rak import√°l√°sa

```javascript
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'
```
A @tanstack/react-query k√∂nyvt√°rb√≥l h√°rom dolgot import√°lunk:

QueryClient: a QueryClient oszt√°ly felel≈ës a lek√©rdez√©sek kezel√©s√©√©rt √©s gyors√≠t√≥t√°raz√°s√°√©rt.
QueryClientProvider: ez a komponens egy kontextust biztos√≠t a React komponens f√°n kereszt√ºl, amelyben el√©rhet≈ëv√© teszi a QueryClient-et.
useQuery: egy hook, amelyet a lek√©rdez√©sek futtat√°s√°ra haszn√°lunk; aszinkron adatlek√©r√©sre √©s annak √°llapot√°nak kezel√©s√©re szolg√°l.
QueryClient p√©ld√°ny l√©trehoz√°sa
javascript
K√≥d m√°sol√°sa
const queryClient = new QueryClient()
Itt l√©trehozunk egy QueryClient p√©ld√°nyt, amely majd az √∂sszes lek√©rdez√©s√ºnket kezeli √©s gyors√≠t√≥t√°razza.

## F≈ë App komponens defini√°l√°sa
```javascript

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```
Az App komponens a teljes alkalmaz√°s kezd≈ëpontja. A QueryClientProvider k√∂r√© csomagolja az Example komponenst, √©s a client propk√©nt √°tadja neki a queryClient p√©ld√°nyt. Ezzel a kontextus minden bels≈ë komponens sz√°m√°ra el√©rhet≈ëv√© v√°lik, hogy haszn√°lni tudj√°k a @tanstack/react-query szolg√°ltat√°sait.

## Example komponens defini√°l√°sa
```javascript
K√≥d m√°sol√°sa
function Example() {
  const { isPending, error, data } = useQuery({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/TanStack/query').then((res) =>
        res.json(),
      ),
  })
```
Az Example komponens v√©gzi az adatlek√©r√©st a useQuery hook seg√≠ts√©g√©vel:

queryKey: A queryKey egy egyedi azonos√≠t√≥ a lek√©rdez√©s sz√°m√°ra. Itt a ['repoData'] kulcsot haszn√°ljuk, ami seg√≠t a react-query-nek a gyors√≠t√≥t√°raz√°s √©s √∫jrak√©r√©s kezel√©s√©ben.
queryFn: A queryFn egy f√ºggv√©ny, amely v√©grehajtja az adatlek√©r√©st. Itt a fetch API-t haszn√°ljuk, hogy adatokat k√©rj√ºnk le a GitHub API-r√≥l. Az URL v√©g√©n a TanStack/query el√©r√©si √∫t a TanStack projekt query repository-j√°ra mutat. A lek√©rt adatokat .json()-n√° alak√≠tjuk.
Visszat√©r√©si √©rt√©kek √©s felt√©telek
```javascript
  if (isPending) return 'Loading...'
  if (error) return 'An error has occurred: ' + error.message
```
isPending: Ha az adatok lek√©r√©se m√©g folyamatban van, Loading... sz√∂veget jelen√≠t√ºnk meg.
error: Ha hiba t√∂rt√©nt az adatok lek√©r√©sekor, egy hiba√ºzenetet adunk vissza.
Adatok megjelen√≠t√©se
```javascript

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
    </div>
  )
}
```
Ha az adatlek√©r√©s sikeres volt, megjelen√≠tj√ºk a k√∂vetkez≈ë adatokat:

data.name: a repository neve
data.description: a repository le√≠r√°sa
data.subscribers_count: a repository figyel≈ëinek sz√°ma üëÄ
data.stargazers_count: a repository csillagainak sz√°ma ‚ú®
data.forks_count: a repository forkol√°sainak sz√°ma üç¥
Ez a k√≥d teh√°t aszinkron m√≥don lek√©rdezi egy GitHub repository adatait, √©s megjelen√≠ti azokat a fel√ºleten, kezelve a t√∂lt√©si √©s hiba√°llapotokat is.

# F≈ëbb alapfogalmak

* 1. Queries
* 2. Mutations
* 3. Query Invalidation

## 1. Queries
  B√°rmilyen Promise alap√∫ adatkinyer√©sre haszn√°lhat√≥ (f≈ëleg fetch-re fogjuk.)
 Alpja a useQuery hook, amelyet olyan komponensekben lehet haszn√°lni, amik <QueryClientProvider client={peldanyositottQueryClient}>-be vannak √°gyazva.

A useQuery TanStak hook minimum elv√°rja a k√∂vetkez≈ë be√°ll√≠t√°sokat:
	- queryKey : egyedi azonos√≠t√≥ a lek√©rdez√©shez
	- queryFn : a funkci√≥, ami egy fetch-et tartalmaz

Visszad egy objektumot, egy sor inform√°ci√≥val az API h√≠v√°ssal kapcsolatban. A legfontosabbak:
	- status: ez "pending"/"success"/"error", ugyanezek boolen-ben:
	- isError, isPending, isSucces;
	- data: Maga a fetch eredm√©nye, ami akkor √°ll rendelkez√©re, ha m√°r lez√°rult (isPending == false) √©s sikeres volt a fetch (isSucces== true || isError == false).
	- error: Ha hiba van, rendelkez√©sre √°ll egy error object, amib≈ël pl. a message kiolvashat√≥.
√çGY:
```javascript

 const { status, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })
```
## 2. Mutations
Ez teszi lehet≈ëv√© a szerver oldali v√°ltoztat√°sokat (create/ update/ delete, vagy egy√©b szerver oldali side-effects).
Ehhez a useMutation TanStack hookot haszn√°lhatjuk.

A mutation can only be in one of the following states at any given moment:

isIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state
isPending or status === 'pending' - The mutation is currently running
isError or status === 'error' - The mutation encountered an error
isSuccess or status === 'success' - The mutation was successful and mutation data is available
Ha pedig m√°r lefutott:
error - ha a mutation hiba √°llapotban van, akkor az error objektum el√©rhet≈ë az 'error' property-n kereszt√ºl.
data - ha a mutation sikeres, azaz 'success' √°llapotban van, akkor az adat objektum a 'data' property-n kereszt√ºl.

Haszn√°lata √≠gy:
```javascript
 const mutation = useMutation({
    mutationFn: (formData) => {
      return fetch('/api', formData)
    },
  })
```
## 3. Query Invalidation - lek√©rdez√©s √©rv√©nytelen√≠t√©s
	A TanStack Query egyik el≈ëny√∂s funkci√≥ja, hogy t√°rolja az el≈ëz≈ë szerver k√©r√©sek eredm√©ny√©t, ezzel gyors√≠tva a felhaszn√°l√≥i √©lm√©nyt. Ugyanakkor emiatt lehets√©ges, hogy nem aktu√°lis ("stale" "√°llott") szerver-inform√°ci√≥t ad vissza (p√©ld√°ul, mert a User √©ppen megv√°ltoztatta azt). Ennek lehet elej√©t venni a Query Invalidation-el, mert √≠gy mi t√∂r√∂lhetj√ºk az el≈ëz≈ë lek√©rdez√©s adatait.

A QueryClient met√≥dusa ez.
```javascript
// Invalidate every query in the cache
queryClient.invalidateQueries();
// Invalidate every query with a key that starts with `todos`
queryClient.invalidateQueries({ queryKey: ['todos'] })
```
Az invalidateQueries met√≥dus hat√°s√°ra elavultt√° (stale) v√°lik a megadott lek√©rdez√©s, 
am miatt:
	* 1) Fel√ºl√≠rja a useQuery hookok "staleTime" bell√≠t√°sait (ami nem tudom mire kell);
	* 2) Ha √©ppen folyamatban van lek√©rdez√©s az adott azonos√≠t√≥val, akkor az √∫jraindul