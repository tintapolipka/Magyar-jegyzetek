# Design patterns
Forr√°s:
https://www.freecodecamp.org/news/javascript-design-patterns-explained/#heading-what-are-design-patterns
https://fireship.io/lessons/typescript-design-patterns/
Aj√°nlott:
https://www.youtube.com/watch?v=tv-_1er1mWI

Eredetileg az 1994-es "Design Patterns: Elements of Reusable Object-Oriented Software" c√≠m≈± k√∂nyvben jelentek meg C++ programoz√°si nyelvre. Objektum orient√°lt nyelvekre tal√°lt√°k ki az√©rt, hogy cs√∂kkents√©k a k√≥d ism√©tl√©seket. Ezek k√∂z√ºl nem mind alkalmazhat√≥ JavaScriptben, de ami igen, azok itt vannak:

## H√°rom csoportjuk van:
* Creational Design Patterns
* Structural Design Patterns
* Behavioral Design Patterns
---
## Creational Design Patterns
### 1. Singleton:
Egy olyan objektumot jel√∂l, aminek csak egy m√≥dos√≠thatatlan v√°ltozata l√©tezik a k√≥dban. √ârdemes glob√°lisan defini√°lni, hogy mindenhonnan el√©rhet≈ë legyen a k√≥dban.

Typescriptben:
A logik√°ja az, hogy a class-on bel√ºl egy constructor-t√≥l k√ºl√∂nb√∂z≈ë met√≥dussal hozzuk l√©tre √∂nmaga p√©ld√°ny√°t. Ez a p√©ld√°ny "static" el≈ëtaggal v√©dett, √≠gy a class-hoz tartozik, √©s nem az egyes p√©ld√°nyokhoz, teh√°t minden p√©ld√°ny osztozna rajta. Ugyanakkor nem is lehet l√©trehozni "new" kulcssz√≥val √∫j p√©ld√°nyt m√°shogyan, csak a bels≈ë met√≥dussal, mivel a constructor-t "private" el≈ëtaggal defini√°ljuk, ami csak a class-on bel√ºlr≈ël el√©rhet≈ë. V√©g√ºl az egyetlen p√©ld√°nyt a classon bel√ºl l√©trehoz√≥ met√≥dusban ellen≈ërizz√ºk, hogy van-e m√°r bels≈ë p√©ld√°ny. Ha van, akkor visszadja, ha nincs akkor l√©trehozza √©s ut√°na adja vissza a k√©sz singletont.

~~~typescript

class Settings {

  static instance: Settings; /*
	static kulcssz√≥: Ez azt jelenti, hogy az instance v√°ltoz√≥ az oszt√°lyhoz tartozik, nem az egyes p√©ld√°nyokhoz. Minden oszt√°lyp√©ld√°ny ugyanazt a instance √©rt√©ket osztja meg.
	T√≠pusmegjel√∂l√©s: Az instance t√≠pus√°t Settings oszt√°lyra √°ll√≠tjuk, azaz csak ilyen t√≠pus√∫ √©rt√©keket vehet fel.
Ez a v√°ltoz√≥ t√°rolja majd a Singleton p√©ld√°nyt.
*/
  public readonly mode = 'dark';
  
  private constructor(){}
/*
A private kulcssz√≥ biztos√≠tja, hogy az oszt√°ly konstruktor√°t k√≠v√ºlr≈ël (azaz a new kulcssz√≥val) ne lehessen megh√≠vni.
Ez a Singleton egyik legfontosabb r√©sze, mert √≠gy garant√°lhat√≥, hogy csak az oszt√°lyon bel√ºl (statikus met√≥dusokon kereszt√ºl) lehet p√©ld√°nyt l√©trehozni.
*/

  static getInstance(): Settings {
    if (!Settings.instance) {
      Settings.instance = new Settings();
    }

    return Settings.instance;
  }
	/*
Ez egy statikus met√≥dus, amely az oszt√°ly szintj√©n √©rhet≈ë el (√≠gy: Settings.getInstance()). A c√©lja, hogy biztos√≠tsa a p√©ld√°nyhoz val√≥ hozz√°f√©r√©st. Ellen≈ërzi, hogy a Settings.instance v√°ltoz√≥ tartalmaz-e m√°r egy p√©ld√°nyt.
Ha nincs p√©ld√°ny (azaz undefined az √©rt√©ke), akkor l√©trehoz egyet. Mivel a constuctor priv√°t, ez√©rt csak bel√ºlr≈ël hozhat√≥ l√©tre p√©ld√°nya, ami itt t√∂rt√©nik meg. Ha azonban m√°r l√©tezik egy p√©ld√°ny, akkor az √∫jb√≥li l√©trehoz√°s helyett azonnal vissza is t√©r vele.
	*/
}

const settings = new Settings() /*
Hib√°t dob, mivel a new kulcssz√≥ haszn√°lata nem lehets√©ges k√≠v√ºlr≈ël, mert a konstruktor priv√°t. Ez garant√°lja a Singleton minta m≈±k√∂d√©s√©t.
*/ 
const settings = Settings.getInstance(); // √≠gy m≈±k√∂dik csak.
~~~

Hagyom√°nyos defini√°l√°ssal:
~~~javascript
const Config = {
  start: () => console.log('App has started'),
  update: () => console.log('App has updated'),
}

// We freeze the object to prevent new properties being added and existing properties being modified or removed
Object.freeze(Config)

Config.start() // "App has started"
Config.update() // "App has updated"

Config.name = "Robert" // We try to add a new key
console.log(Config) // And verify it doesn't work: { start: [Function: start], update: [Function: update] }
~~~

Class seg√≠ts√©g√©vel l√©trehozva:
~~~javascript
class Config {
    constructor() {}
    start(){ console.log('App has started') }  
    update(){ console.log('App has updated') }
}

const instance = new Config()
Object.freeze(instance)
~~~
Mindk√©t m√≥don l√©trehozva az Object.freeze() met√≥dussal lehet "befagyasztani" a l√©trehozott p√©ld√°nyt.

TypeScriptben:
A constructor-t kell private-k√©nt megadni, √≠gy

### 2. Factory Method Pattern
A l√©nyege, hogy egy helyre van centraliz√°lva t√∂bb k√ºl√∂nb√∂z≈ë helyen felhaszn√°lhat√≥ objektum v√°za. Ezek gyakorlatilag a Js-ben a class-ok √©s a factory funkci√≥k.

### 3. Abstract Factory Pattern
Ha j√≥l√©rtem ezek olyan funkci√≥k, amikben √∂sszegy≈±jtenek classokat, √©s a beadott adat alapj√°n eld√∂ntik, hogy milyen konkr√©t class-okat kell haszn√°lni ebben az esetben a p√©ld√°nyos√≠t√°sra. Ezek teh√°t egy absztrakt szintet tesznek a sima classokra, de cser√©be nem kell eml√©kezni a fejleszt≈ënek, hogy pontosan melyik konkr√©t classt p√©ld√°nyos√≠ts√°k, mert ezt tudja az abstract factory class.

~~~javascript

// We have a class or "concrete factory" for each vehicle type
class Car {
    constructor () {
        this.name = "Car"
        this.wheels = 4
    }
    turnOn = () => console.log("Chacab√∫m!!")
}

class Truck {
    constructor () {
        this.name = "Truck"
        this.wheels = 8
    }
    turnOn = () => console.log("RRRRRRRRUUUUUUUUUMMMMMMMMMM!!")
}


// And and abstract factory that works as a single point of interaction for our clients
// Given the type parameter it receives, it will call the corresponding concrete factory
const vehicleFactory = {
    createVehicle: function (type) {
        switch (type) {
            case "car":
                return new Car()
            case "truck":
                return new Truck()
            
            default:
                return null
        }
    }
}

const car = vehicleFactory.createVehicle("car") // Car { turnOn: [Function: turnOn], name: 'Car', wheels: 4 }
const truck = vehicleFactory.createVehicle("truck") // Truck { turnOn: [Function: turnOn], name: 'Truck', wheels: 8 }
~~~
### 4.Builder Pattern
A builder funkci√≥ egy objektumot fogad, √©s hozz√°ad bizonyos √∫j met√≥dusokat/mez≈ëket. A l√©nyege, hogy l√©p√©sekree bontj√°k az objektumok fel√©p√≠t√©s√©t, de egyes l√©p√©sek √©s ezzel egyes nem sz√ºks√©ges met√≥dusok/mez≈ëk kihagyhat√≥k lesznek. 
~~~javascript
// We declare our objects
const bug1 = {
    name: "Buggy McFly",
    phrase: "Your debugger doesn't work with me!"
}

const bug2 = {
    name: "Martiniano Buggland",
    phrase: "Can't touch this! Na na na na..."
}

// These functions take an object as parameter and add a method to them
const addFlyingAbility = obj => {
    obj.fly = () => console.log(`Now ${obj.name} can fly!`)
}

const addSpeechAbility = obj => {
    obj.saySmthg = () => console.log(`${obj.name} walks the walk and talks the talk!`)
}

// Finally we call the builder functions passing the objects as parameters
addFlyingAbility(bug1)
bug1.fly() // output: "Now Buggy McFly can fly!"

addSpeechAbility(bug2)
bug2.saySmthg() // output: "Martiniano Buggland walks the walk and talks the talk!"
~~~

### Prototype Pattern
The Prototype pattern allows you to create an object using another object as a blueprint, inheriting its properties and methods.
Kulcsa az Object.setPrototypeOf(aminekBeallitom, amitbeallitok) met√≥dus.

~~~javascript
const supertype = { attack: ()=>{console.warn("Attack!")} };
const subtype = {weapon: "sword"};
Object.setPrototypeOf(subtype,supertype);
// Innent≈ël a subtype is rendekezik attack met√≥dussal:
subtype.attack() // Attack!
// A supertype-hoz adott tov√°bbi met√≥dust/mez≈ët pedig √∂r√∂kli a subtype is!
supertype.defend = ()=>{console.log("Defend!")};
subtype.defend() // Defend!
~~~
## Structural Design Patterns

Structural patterns refer to how to assemble objects and classes into larger structures.

### Adapter Pattern
Az adapter minta lehet≈ëv√© teszi k√©t inkompatibilis objektum interakci√≥j√°t egym√°ssal. Pl.: Xml √©s JSON √°talak√≠t√°sa egym√°ss√°.

~~~javascript
// k√©tf√©le sz√°mkifejez√©s illeszt√©se:
const citiesHabitantsInMillions = [
    { city: "London", habitants: 8.9 },
    { city: "Rome", habitants: 2.8 },
] 
// A t√∂mbbe kellene illeszteni ezt:
const BuenosAires = { city: "Buenos Aires", habitants: 3100000}

// ez lesz az adapter:
const toMillionsAdapter = city => { city.habitants = parseFloat((city.habitants/1000000).toFixed(1)) }

// azonos form√°tumra hozzuk adapterrel a milli√≥kat:
toMillionsAdapter(BuenosAires)

// mostm√°r hozz√°adhat√≥
citiesHabitantsInMillions.push(BuenosAires)
~~~

### Decorator Pattern
The Decorator pattern lets you attach new behaviors to objects by placing them inside wrapper objects that contain the behaviors. If you're somewhat familiar with React and higher order components (HOC) this kind of approach probably rings a bell for you.

### Facade Pattern (homlokzat, arculat)
The Facade pattern provides a simplified interface to a library, a framework, or any other complex set of classes.

Examples:
*declarative programming, it's all about providing abstractions that hide away complexity from the eyes of the developer.

*JavaScript's map, sort, reduce and filter functions, which all work like good 'ol for loops beneath the hood.

*libraries used for UI (MUI)

### Proxy Pattern
The Proxy pattern provides a substitute or placeholder for another object. The idea is to control access to the original object, performing some kind of action before or after the request gets to the actual original object.

Again, if you're familiar with ExpressJS this probably rings a bell for you. Express is a framework used to develop NodeJS APIs, and one of the features it has is the use of Middlewares. Middlewares are nothing more than pieces of code we can make execute before, in the middle, or after any request reaches our endpoints.

## Behavioral Design Patterns
Behavioral patterns control communication and the assignment of responsibilities between different objects.

Chain of Responsibility Pattern
The Chain of Responsibility passes requests along a chain of handlers. Each handler decides either to process the request or to pass it to the next handler in the chain.

Think about any system in which you have certain information to process along many steps. At each step a different entity is in charge of performing an action, and the information only gets passed to another entity if a certain condition is met.

A typical front-end app that consumes an API could work as an example:

We have a function responsible for rendering a UI component.

Once rendered, a another function makes a request to an API endpoint.

If the endpoint response is as expected, the information is passed to another function that sorts the data in a given way and stores it in a variable.

Once that variable stores the needed information, another function is responsible of rendering it in the UI.

We can see how here we have many different entities that collaborate to execute a certain task. Each of them is responsible for a single "step" of that task, which helps with code modularity and separation of concerns.üëåüëå

### Iterator Pattern
The iterator is used to traverse elements of a collection. This might sound trivial in programming languages used nowadays, but this wasn't always the case.

Anyway, any of the JavaScript built in functions we have at our disposal to iterate over data structures (for, forEach, for...of, for...in, map, reduce, filter, and so on) are examples of the iterator pattern.

Same as any traversing algorithm we code to iterate through more complex data structures like trees or graphs.

### Observer Pattern
The observer pattern lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they‚Äôre observing. Basically, it's like having an event listener on a given object, and when that object performs the action we're listening for, we do something.

React's useEffect hook might be a good example here. What useEffect does is execute a given function at the moment we declare.

The hook is divided in two main parts, the executable function and an array of dependencies. If the array is empty, like in the following example, the function gets executed each time the component is rendered.

  useEffect(() => { console.log('The component has rendered') }, [])
If we declare any variables within the dependency array, the function will execute only when those variables change.

  useEffect(() => { console.log('var1 has changed') }, [var1])
Even plain old JavaScript event listeners can be thought of as observers. Also, reactive programming and libraries like RxJS, which are used to handle asynchronous information and events along systems, are good examples of this pattern.

Roundup
If you'd like to know more about this topic, I recommend this great Fireship video and this awesome website where you can find very detailed explanations with illustrations to help you understand each pattern.

As always, I hope you enjoyed the article and learned something new. If you want, you can also follow me on LinkedIn or Twitter.

Cheers and see you in the next one! ‚úåÔ∏è

Image

